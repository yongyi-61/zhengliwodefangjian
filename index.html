<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å›¾å½¢æ”¶é›†ä¸æ•´ç†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Arial Rounded MT Bold', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #5a3921;
            overflow-x: hidden;
            padding: 10px;
        }
        
        .container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
        }
        
        header {
            text-align: center;
            padding: 8px 0;
        }
        
        h1 {
            font-size: 1.6rem;
            color: #8b4513;
            margin-bottom: 4px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            font-size: 0.9rem;
            color: #a0522d;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
        }
        
        @media (min-width: 768px) {
            .game-area {
                flex-direction: row;
            }
            
            .game-board-container {
                flex: 2;
            }
            
            .storage-area {
                flex: 1;
            }
        }
        
        .game-board-container {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            flex: 1;
            min-height: 300px;
        }
        
        @media (max-width: 380px) {
            .game-board {
                grid-template-columns: repeat(4, 1fr);
                gap: 5px;
            }
        }
        
        @media (min-width: 600px) {
            .game-board {
                grid-template-columns: repeat(6, 1fr);
                gap: 8px;
            }
        }
        
        .card {
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            font-size: 1.5rem;
            background: rgba(255, 255, 255, 0.7);
            user-select: none;
            aspect-ratio: 1/1;
            touch-action: none;
        }
        
        @media (max-width: 380px) {
            .card {
                font-size: 1.3rem;
            }
        }
        
        .card.darkened {
            background: rgba(210, 180, 140, 0.8);
            box-shadow: 0 0 0 2px #8b4513;
        }
        
        .card.double-darkened {
            background: rgba(160, 120, 80, 0.8);
            box-shadow: 0 0 0 3px #8b4513;
        }
        
        .card.dragging {
            opacity: 0.7;
            transform: scale(1.1);
            z-index: 10;
        }
        
        .card.matched {
            animation: matched 0.5s ease forwards;
        }
        
        @keyframes matched {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { 
                transform: scale(0);
                opacity: 0;
            }
        }
        
        .actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: #d2691e;
            color: white;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            flex: 1;
            min-width: 120px;
            max-width: 140px;
        }
        
        button:hover {
            background: #b35917;
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .storage-area {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .storage-title {
            text-align: center;
            margin-bottom: 12px;
            font-size: 1.2rem;
            color: #8b4513;
        }
        
        .storage-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .storage-box {
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            padding: 10px;
            min-height: 70px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }
        
        .storage-box.active-drop {
            background: rgba(210, 180, 140, 0.5) !important;
            border: 2px dashed #8b4513;
            transform: scale(1.05);
        }
        
        .storage-box:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
        }
        
        .storage-box h3 {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1rem;
            color: #8b4513;
        }
        
        .storage-count {
            background: #d2691e;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            margin-left: auto;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            padding: 12px;
            margin-top: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            font-size: 0.85rem;
        }
        
        .instructions h2 {
            margin-bottom: 8px;
            font-size: 1.1rem;
            color: #8b4513;
        }
        
        .instructions ul {
            padding-left: 18px;
        }
        
        .instructions li {
            margin-bottom: 5px;
            line-height: 1.4;
        }
        
        /* æ–°è¡¨æƒ…ç”ŸæˆåŠ¨ç”» */
        .new-emoji {
            animation: appear 0.5s ease;
        }
        
        @keyframes appear {
            0% { transform: scale(0); opacity: 0; }
            70% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* æ”¶çº³è¯¦æƒ…å¼¹çª— */
        .storage-detail {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            padding: 15px;
        }
        
        .storage-detail.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .storage-detail-content {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 15px;
            padding: 20px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .storage-detail h2 {
            font-size: 1.5rem;
            margin-bottom: 12px;
            color: #8b4513;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .detail-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-top: 15px;
        }
        
        .detail-item {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-size: 1.5rem;
            background: rgba(255, 255, 255, 0.8);
        }
        
        @media (max-width: 380px) {
            .detail-item {
                width: 45px;
                height: 45px;
                font-size: 1.3rem;
            }
        }
        
        .close-btn {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
        }
        
        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 767px) {
            .container {
                gap: 8px;
            }
            
            header {
                padding: 5px 0;
            }
            
            h1 {
                font-size: 1.4rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            .game-board-container {
                padding: 10px;
            }
            
            .storage-area {
                padding: 10px;
            }
            
            .instructions {
                padding: 10px;
            }
        }
        
        /* é˜²æ­¢æ–‡å­—é€‰ä¸­ */
        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* é•¿æŒ‰æç¤º */
        .long-press-hint {
            position: absolute;
            bottom: 5px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.7rem;
            color: #8b4513;
            opacity: 0.7;
        }
        
        /* æ‹–æ‹½æŒ‡ç¤ºå™¨ */
        .drag-indicator {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 class="no-select">å›¾å½¢æ”¶é›†ä¸æ•´ç†</h1>
            <p class="subtitle no-select">æ‹–åŠ¨ç›¸åŒè¡¨æƒ…å åŠ åˆæˆï¼Œæ•´ç†ç‰©å“åˆ°å¯¹åº”ä½ç½®</p>
        </header>
        
        <div class="game-area">
            <div class="game-board-container">
                <div class="game-board" id="gameBoard">
                    <!-- è¡¨æƒ…å¡ç‰‡å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
                </div>
                
                <div class="actions">
                    <button id="hintBtn">æç¤º</button>
                    <button id="shuffleBtn">é‡æ’</button>
                </div>
            </div>
            
            <div class="storage-area">
                <h2 class="storage-title no-select">æ”¶çº³åŒº</h2>
                <div class="storage-container">
                    <div class="storage-box" id="wardrobeBox" data-type="clothing">
                        <h3 class="no-select">
                            <i>ğŸ‘•</i> è¡£æŸœ (è¡£ç‰©)
                            <span class="storage-count" id="wardrobeCount">0</span>
                        </h3>
                    </div>
                    <div class="storage-box" id="deskBox" data-type="stationery">
                        <h3 class="no-select">
                            <i>ğŸ“</i> ä¹¦æ¡Œ (æ–‡å…·)
                            <span class="storage-count" id="deskCount">0</span>
                        </h3>
                    </div>
                    <div class="storage-box" id="toyboxBox" data-type="toy">
                        <h3 class="no-select">
                            <i>ğŸ§¸</i> ç©å…·ç®± (ç©å…·)
                            <span class="storage-count" id="toyboxCount">0</span>
                        </h3>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h2 class="no-select">æ¸¸æˆè¯´æ˜</h2>
            <ul class="no-select">
                <li>é•¿æŒ‰å¹¶æ‹–åŠ¨è¡¨æƒ…åˆ°ç›¸åŒè¡¨æƒ…ä¸Šè¿›è¡Œå åŠ </li>
                <li>å åŠ ä½ç½®èƒŒæ™¯è‰²ä¼šå˜æ·±ï¼Œè¡¨ç¤ºå·²å åŠ æ•°é‡</li>
                <li>å åŠ ä¸‰ä¸ªç›¸åŒè¡¨æƒ…ä¼šåˆæˆè¡£ç‰©ã€æ–‡å…·æˆ–ç©å…·</li>
                <li>å°†åˆæˆç‰©å“æ‹–æ”¾åˆ°å¯¹åº”çš„æ”¶çº³åŒºåŸŸ</li>
                <li>ç‚¹å‡»æ”¶çº³åŒºåŸŸæŸ¥çœ‹å·²æ”¶é›†çš„ç‰©å“</li>
            </ul>
        </div>
    </div>

    <!-- æ”¶çº³è¯¦æƒ…å¼¹çª— -->
    <div class="storage-detail" id="storageDetail">
        <div class="storage-detail-content">
            <h2 id="detailTitle" class="no-select"><i>ğŸ‘•</i> è¡£æŸœ</h2>
            <div class="detail-items" id="detailItems">
                <!-- ç‰©å“å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button class="close-btn" id="closeDetail">å…³é—­</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            board: [],
            gameActive: true,
            emojiCounts: {},
            dragSource: null,
            storage: {
                clothing: [],
                stationery: [],
                toy: []
            },
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            currentDragItem: null,
            dragIndicator: null
        };

        // è¡¨æƒ…ç±»å‹
        const emojis = ['ğŸ¶', 'ğŸ±', 'ğŸ°', 'ğŸ»', 'ğŸ¼', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸'];
        
        // åˆæˆç‰©å“ç±»å‹
        const itemTypes = {
            clothing: [
                { emoji: 'ğŸ‘•', class: 'item-shirt' },
                { emoji: 'ğŸ‘–', class: 'item-pants' },
                { emoji: 'ğŸ§¢', class: 'item-hat' },
                { emoji: 'ğŸ‘”', class: 'item-shirt' },
                { emoji: 'ğŸ‘—', class: 'item-pants' },
                { emoji: 'ğŸ¥¼', class: 'item-hat' },
                { emoji: 'ğŸ©³', class: 'item-shirt' },
                { emoji: 'ğŸ‘š', class: 'item-pants' },
                { emoji: 'ğŸ§¦', class: 'item-hat' }
            ],
            stationery: [
                { emoji: 'ğŸ–Šï¸', class: 'item-pen' },
                { emoji: 'âœï¸', class: 'item-pencil' },
                { emoji: 'ğŸ““', class: 'item-notebook' },
                { emoji: 'ğŸ“”', class: 'item-pen' },
                { emoji: 'ğŸ“’', class: 'item-pencil' },
                { emoji: 'ğŸ“•', class: 'item-notebook' },
                { emoji: 'ğŸ“—', class: 'item-pen' },
                { emoji: 'ğŸ“˜', class: 'item-pencil' },
                { emoji: 'ğŸ“™', class: 'item-notebook' },
                { emoji: 'ğŸ“š', class: 'item-pen' },
                { emoji: 'ğŸ“–', class: 'item-pencil' }
            ],
            toy: [
                { emoji: 'ğŸ§¸', class: 'item-toy' },
                { emoji: 'ğŸ‘¶', class: 'item-doll' },
                { emoji: 'ğŸš—', class: 'item-car' },
                { emoji: 'ğŸš‚', class: 'item-toy' },
                { emoji: 'âœˆï¸', class: 'item-doll' },
                { emoji: 'ğŸš', class: 'item-car' },
                { emoji: 'ğŸš²', class: 'item-toy' },
                { emoji: 'ğŸ›´', class: 'item-doll' },
                { emoji: 'ğŸ€', class: 'item-car' },
                { emoji: 'âš½', class: 'item-toy' },
                { emoji: 'ğŸ®', class: 'item-doll' },
                { emoji: 'ğŸ²', class: 'item-car' }
            ]
        };

        // DOM å…ƒç´ 
        const gameBoardEl = document.getElementById('gameBoard');
        const hintBtn = document.getElementById('hintBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const storageDetailEl = document.getElementById('storageDetail');
        const detailTitleEl = document.getElementById('detailTitle');
        const detailItemsEl = document.getElementById('detailItems');
        const closeDetailBtn = document.getElementById('closeDetail');
        const wardrobeCountEl = document.getElementById('wardrobeCount');
        const deskCountEl = document.getElementById('deskCount');
        const toyboxCountEl = document.getElementById('toyboxCount');

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            generateBoard();
            
            // äº‹ä»¶ç›‘å¬
            hintBtn.addEventListener('click', showHint);
            shuffleBtn.addEventListener('click', shuffleBoard);
            closeDetailBtn.addEventListener('click', closeStorageDetail);
            
            // è®¾ç½®æ”¾ç½®åŒºåŸŸ
            setupDropZones();
            
            // è®¾ç½®æ”¶çº³åŒºç‚¹å‡»äº‹ä»¶
            setupStorageClick();
            
            // ç§»åŠ¨ç«¯ä¼˜åŒ–
            if (gameState.isMobile) {
                setupMobileOptimizations();
            }
            
            // åˆ›å»ºæ‹–æ‹½æŒ‡ç¤ºå™¨
            createDragIndicator();
        }

        // ç”Ÿæˆæ¸¸æˆæ¿
        function generateBoard() {
            gameBoardEl.innerHTML = '';
            gameState.board = [];
            gameState.emojiCounts = {};
            
            // æ ¹æ®å±å¹•å¤§å°è°ƒæ•´å¡ç‰‡æ•°é‡
            let cardCount;
            if (window.innerWidth < 380) {
                cardCount = 16; // 4x4
            } else if (window.innerWidth < 600) {
                cardCount = 20; // 5x4
            } else {
                cardCount = 30; // 6x5
            }
            
            for (let i = 0; i < cardCount; i++) {
                createNewEmoji();
            }
        }

        // åˆ›å»ºæ–°è¡¨æƒ…
        function createNewEmoji(parentElement) {
            const emoji = emojis[Math.floor(Math.random() * emojis.length)];
            
            const card = document.createElement('div');
            card.className = 'card new-emoji';
            card.textContent = emoji;
            card.dataset.emoji = emoji;
            card.dataset.count = 1; // åˆå§‹è®¡æ•°ä¸º1
            
            // æ·»åŠ æ‹–æ‹½äº‹ä»¶
            setupCardEvents(card);
            
            if (parentElement) {
                parentElement.appendChild(card);
            } else {
                gameBoardEl.appendChild(card);
                gameState.board.push(card);
            }
            
            // æ›´æ–°è¡¨æƒ…è®¡æ•°
            gameState.emojiCounts[emoji] = (gameState.emojiCounts[emoji] || 0) + 1;
            
            return card;
        }

        // è®¾ç½®å¡ç‰‡äº‹ä»¶
        function setupCardEvents(card) {
            card.setAttribute('draggable', true);
            
            // æ¡Œé¢ç«¯äº‹ä»¶
            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);
            card.addEventListener('dragover', handleDragOver);
            card.addEventListener('drop', handleDrop);
            
            // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
            if (gameState.isMobile) {
                card.addEventListener('touchstart', handleTouchStart, { passive: false });
                card.addEventListener('touchmove', handleTouchMove, { passive: false });
                card.addEventListener('touchend', handleTouchEnd);
            }
        }

        // æ‹–æ‹½å¼€å§‹
        function handleDragStart(e) {
            if (!gameState.gameActive) return;
            
            gameState.dragSource = this;
            this.classList.add('dragging');
            e.dataTransfer.setData('text/plain', this.dataset.emoji);
            e.dataTransfer.setData('count', this.dataset.count);
            e.dataTransfer.setData('type', this.dataset.type || 'emoji');
        }

        // æ‹–æ‹½ç»“æŸ
        function handleDragEnd() {
            this.classList.remove('dragging');
            gameState.dragSource = null;
            hideDragIndicator();
        }

        // æ‹–æ‹½ç»è¿‡
        function handleDragOver(e) {
            e.preventDefault();
        }

        // æ”¾ç½®
        function handleDrop(e) {
            e.preventDefault();
            
            if (!gameState.dragSource || this === gameState.dragSource) return;
            
            processDrop(this);
        }

        // å¤„ç†æ”¾ç½®é€»è¾‘
        function processDrop(targetCard) {
            const sourceEmoji = gameState.dragSource.dataset.emoji;
            const targetEmoji = targetCard.dataset.emoji;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„è¡¨æƒ…
            if (sourceEmoji === targetEmoji) {
                const sourceCount = parseInt(gameState.dragSource.dataset.count);
                const targetCount = parseInt(targetCard.dataset.count);
                const newCount = targetCount + sourceCount;
                
                // æ›´æ–°ç›®æ ‡å¡ç‰‡
                targetCard.dataset.count = newCount;
                
                // æ›´æ–°èƒŒæ™¯è‰²
                if (newCount === 2) {
                    targetCard.classList.add('darkened');
                } else if (newCount >= 3) {
                    targetCard.classList.remove('darkened');
                    targetCard.classList.add('double-darkened');
                    
                    // ä¸‰ä¸ªç›¸åŒè¡¨æƒ…ï¼Œåˆæˆæ–°ç‰©å“
                    setTimeout(() => {
                        createNewItem(targetCard);
                    }, 300);
                }
                
                // ç§»é™¤æºå¡ç‰‡
                const sourceIndex = gameState.board.indexOf(gameState.dragSource);
                gameState.dragSource.remove();
                gameState.board.splice(sourceIndex, 1);
                
                // æ›´æ–°è¡¨æƒ…è®¡æ•°
                gameState.emojiCounts[sourceEmoji] -= 1;
                
                // åœ¨åŸä½ç½®ç”Ÿæˆæ–°çš„éšæœºè¡¨æƒ…
                setTimeout(() => {
                    const newCard = createNewEmoji();
                    // ç¡®ä¿æ–°å¡ç‰‡åœ¨æ­£ç¡®çš„ä½ç½®
                    if (sourceIndex < gameBoardEl.children.length) {
                        gameBoardEl.insertBefore(newCard, gameBoardEl.children[sourceIndex]);
                    } else {
                        gameBoardEl.appendChild(newCard);
                    }
                    gameState.board.splice(sourceIndex, 0, newCard);
                }, 200);
            }
        }

        // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶å¤„ç†
        let touchStartX, touchStartY, draggedCard, isDragging = false;

        function handleTouchStart(e) {
            if (!gameState.gameActive) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            draggedCard = this;
            
            // è®¾ç½®é•¿æŒ‰è®¡æ—¶å™¨
            gameState.longPressTimer = setTimeout(() => {
                isDragging = true;
                this.classList.add('dragging');
                showDragIndicator(this.textContent, touchStartX, touchStartY);
                gameState.dragSource = this;
            }, 300); // 300ms é•¿æŒ‰è§¦å‘æ‹–æ‹½
        }

        function handleTouchMove(e) {
            if (!isDragging || !draggedCard) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            const currentX = touch.clientX;
            const currentY = touch.clientY;
            
            // æ›´æ–°æ‹–æ‹½æŒ‡ç¤ºå™¨ä½ç½®
            updateDragIndicator(currentX, currentY);
            
            // æ£€æŸ¥æ˜¯å¦åœ¨æ”¶çº³åŒºåŸŸä¸Šæ–¹
            const storageBoxes = document.querySelectorAll('.storage-box');
            let isOverStorage = false;
            
            storageBoxes.forEach(box => {
                const rect = box.getBoundingClientRect();
                if (currentX >= rect.left && currentX <= rect.right &&
                    currentY >= rect.top && currentY <= rect.bottom) {
                    box.classList.add('active-drop');
                    isOverStorage = true;
                } else {
                    box.classList.remove('active-drop');
                }
            });
        }

        function handleTouchEnd(e) {
            // æ¸…é™¤é•¿æŒ‰è®¡æ—¶å™¨
            clearTimeout(gameState.longPressTimer);
            
            if (!isDragging || !draggedCard) {
                isDragging = false;
                draggedCard = null;
                return;
            }
            
            const touch = e.changedTouches[0];
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;
            
            // æ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨æ”¶çº³åŒºåŸŸ
            const storageBoxes = document.querySelectorAll('.storage-box');
            let droppedOnStorage = false;
            
            storageBoxes.forEach(box => {
                const rect = box.getBoundingClientRect();
                if (touchEndX >= rect.left && touchEndX <= rect.right &&
                    touchEndY >= rect.top && touchEndY <= rect.bottom) {
                    
                    const itemType = draggedCard.dataset.type;
                    const boxType = box.dataset.type;
                    
                    if (itemType && itemType === boxType) {
                        // æ­£ç¡®æ”¾ç½®åˆ°æ”¶çº³åŒº
                        handleStorageDrop(itemType, draggedCard.dataset.emoji);
                        droppedOnStorage = true;
                    } else {
                        // é”™è¯¯æ”¾ç½®
                        alert('ç‰©å“ä¸èƒ½æ”¾åœ¨è¿™é‡Œï¼è¯·æ”¾åˆ°æ­£ç¡®çš„ä½ç½®ã€‚');
                    }
                }
                box.classList.remove('active-drop');
            });
            
            if (!droppedOnStorage) {
                // æ²¡æœ‰æ”¾ç½®åœ¨æ”¶çº³åŒºï¼Œæ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨å¡ç‰‡ä¸Š
                const targetCard = findNearestCard(touchEndX, touchEndY);
                if (targetCard && targetCard !== draggedCard) {
                    gameState.dragSource = draggedCard;
                    processDrop(targetCard);
                }
            }
            
            // é‡ç½®çŠ¶æ€
            draggedCard.classList.remove('dragging');
            draggedCard = null;
            gameState.dragSource = null;
            isDragging = false;
            hideDragIndicator();
        }

        // åˆ›å»ºæ‹–æ‹½æŒ‡ç¤ºå™¨
        function createDragIndicator() {
            gameState.dragIndicator = document.createElement('div');
            gameState.dragIndicator.className = 'drag-indicator';
            gameState.dragIndicator.style.display = 'none';
            document.body.appendChild(gameState.dragIndicator);
        }

        // æ˜¾ç¤ºæ‹–æ‹½æŒ‡ç¤ºå™¨
        function showDragIndicator(emoji, x, y) {
            gameState.dragIndicator.textContent = emoji;
            gameState.dragIndicator.style.display = 'block';
            gameState.dragIndicator.style.left = x + 'px';
            gameState.dragIndicator.style.top = y + 'px';
        }

        // æ›´æ–°æ‹–æ‹½æŒ‡ç¤ºå™¨ä½ç½®
        function updateDragIndicator(x, y) {
            gameState.dragIndicator.style.left = x + 'px';
            gameState.dragIndicator.style.top = y + 'px';
        }

        // éšè—æ‹–æ‹½æŒ‡ç¤ºå™¨
        function hideDragIndicator() {
            gameState.dragIndicator.style.display = 'none';
        }

        // æ‰¾åˆ°æœ€è¿‘çš„å¡ç‰‡
        function findNearestCard(x, y) {
            let nearestCard = null;
            let minDistance = Infinity;
            
            gameState.board.forEach(card => {
                const rect = card.getBoundingClientRect();
                const cardCenterX = rect.left + rect.width / 2;
                const cardCenterY = rect.top + rect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(x - cardCenterX, 2) + 
                    Math.pow(y - cardCenterY, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestCard = card;
                }
            });
            
            return minDistance < 100 ? nearestCard : null; // 100px é˜ˆå€¼
        }

        // åˆ›å»ºæ–°ç‰©å“
        function createNewItem(card) {
            // éšæœºé€‰æ‹©ç‰©å“ç±»å‹
            const typeKeys = Object.keys(itemTypes);
            const itemType = typeKeys[Math.floor(Math.random() * typeKeys.length)];
            
            // éšæœºé€‰æ‹©ç‰©å“
            const item = itemTypes[itemType][Math.floor(Math.random() * itemTypes[itemType].length)];
            
            // æ›¿æ¢å¡ç‰‡ä¸ºç‰©å“
            card.textContent = item.emoji;
            card.classList.remove('double-darkened');
            card.classList.add(item.class);
            card.dataset.type = itemType;
            card.dataset.count = 0; // é‡ç½®è®¡æ•°
            card.dataset.emoji = item.emoji;
        }

        // è®¾ç½®æ”¾ç½®åŒºåŸŸ
        function setupDropZones() {
            const dropZones = [
                { element: document.getElementById('wardrobeBox'), type: 'clothing' },
                { element: document.getElementById('deskBox'), type: 'stationery' },
                { element: document.getElementById('toyboxBox'), type: 'toy' }
            ];
            
            dropZones.forEach(zone => {
                zone.element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    zone.element.classList.add('active-drop');
                });
                
                zone.element.addEventListener('dragleave', () => {
                    zone.element.classList.remove('active-drop');
                });
                
                zone.element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    zone.element.classList.remove('active-drop');
                    
                    const itemType = e.dataTransfer.getData('type');
                    const itemEmoji = e.dataTransfer.getData('text/plain');
                    
                    if (itemType === zone.type) {
                        handleStorageDrop(itemType, itemEmoji);
                    } else {
                        // é”™è¯¯æ”¾ç½®
                        alert('ç‰©å“ä¸èƒ½æ”¾åœ¨è¿™é‡Œï¼è¯·æ”¾åˆ°æ­£ç¡®çš„ä½ç½®ã€‚');
                    }
                });
            });
        }

        // å¤„ç†æ”¶çº³åŒºæ”¾ç½®
        function handleStorageDrop(itemType, itemEmoji) {
            // æ­£ç¡®æ”¾ç½®
            gameState.storage[itemType].push(itemEmoji);
            
            // æ›´æ–°æ”¶çº³è®¡æ•°
            updateStorageCounts();
            
            // ç§»é™¤å·²æ”¾ç½®çš„ç‰©å“
            const sourceIndex = gameState.board.indexOf(gameState.dragSource);
            if (sourceIndex !== -1) {
                gameState.dragSource.remove();
                gameState.board.splice(sourceIndex, 1);
                
                // åœ¨åŸä½ç½®ç”Ÿæˆæ–°çš„éšæœºè¡¨æƒ…
                setTimeout(() => {
                    const newCard = createNewEmoji();
                    // ç¡®ä¿æ–°å¡ç‰‡åœ¨æ­£ç¡®çš„ä½ç½®
                    if (sourceIndex < gameBoardEl.children.length) {
                        gameBoardEl.insertBefore(newCard, gameBoardEl.children[sourceIndex]);
                    } else {
                        gameBoardEl.appendChild(newCard);
                    }
                    gameState.board.splice(sourceIndex, 0, newCard);
                }, 200);
            }
        }

        // è®¾ç½®æ”¶çº³åŒºç‚¹å‡»äº‹ä»¶
        function setupStorageClick() {
            const storageBoxes = document.querySelectorAll('.storage-box');
            
            storageBoxes.forEach(box => {
                box.addEventListener('click', () => {
                    const type = box.dataset.type;
                    showStorageDetail(type);
                });
            });
        }

        // æ˜¾ç¤ºæ”¶çº³è¯¦æƒ…
        function showStorageDetail(type) {
            const items = gameState.storage[type];
            const typeNames = {
                'clothing': 'è¡£æŸœ',
                'stationery': 'ä¹¦æ¡Œ',
                'toy': 'ç©å…·ç®±'
            };
            const typeIcons = {
                'clothing': 'ğŸ‘•',
                'stationery': 'ğŸ“',
                'toy': 'ğŸ§¸'
            };
            
            detailTitleEl.innerHTML = `<i>${typeIcons[type]}</i> ${typeNames[type]}`;
            detailItemsEl.innerHTML = '';
            
            if (items.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.textContent = 'è¿˜æ²¡æœ‰æ”¶é›†åˆ°ç‰©å“';
                emptyMsg.style.textAlign = 'center';
                emptyMsg.style.color = '#8b4513';
                emptyMsg.style.padding = '20px';
                detailItemsEl.appendChild(emptyMsg);
            } else {
                items.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'detail-item';
                    itemEl.textContent = item;
                    detailItemsEl.appendChild(itemEl);
                });
            }
            
            storageDetailEl.classList.add('active');
        }

        // å…³é—­æ”¶çº³è¯¦æƒ…
        function closeStorageDetail() {
            storageDetailEl.classList.remove('active');
        }

        // æ›´æ–°æ”¶çº³è®¡æ•°
        function updateStorageCounts() {
            wardrobeCountEl.textContent = gameState.storage.clothing.length;
            deskCountEl.textContent = gameState.storage.stationery.length;
            toyboxCountEl.textContent = gameState.storage.toy.length;
        }

        // ç§»åŠ¨ç«¯ä¼˜åŒ–è®¾ç½®
        function setupMobileOptimizations() {
            // æ·»åŠ é•¿æŒ‰æç¤º
            const hint = document.createElement('div');
            hint.className = 'long-press-hint no-select';
            hint.textContent = 'é•¿æŒ‰å¹¶æ‹–åŠ¨è¡¨æƒ…è¿›è¡Œå åŠ ';
            document.querySelector('.game-board-container').appendChild(hint);
            
            // ä¼˜åŒ–æŒ‰é’®å¤§å°
            document.querySelectorAll('button').forEach(btn => {
                btn.style.padding = '12px 16px';
                btn.style.minWidth = '110px';
            });
        }

        // æ˜¾ç¤ºæç¤º
        function showHint() {
            if (!gameState.gameActive) return;
            
            // æŸ¥æ‰¾å¯èƒ½çš„åŒ¹é…
            let hintEmoji = null;
            
            for (const emoji in gameState.emojiCounts) {
                if (gameState.emojiCounts[emoji] >= 2) {
                    hintEmoji = emoji;
                    break;
                }
            }
            
            if (hintEmoji) {
                // é«˜äº®æ˜¾ç¤ºåŒ¹é…çš„è¡¨æƒ…
                gameState.board.forEach(card => {
                    if (card.dataset.emoji === hintEmoji && card.dataset.count < 3) {
                        card.style.boxShadow = '0 0 0 3px #8b4513, 0 5px 15px rgba(0, 0, 0, 0.3)';
                        
                        setTimeout(() => {
                            card.style.boxShadow = '';
                        }, 2000);
                    }
                });
            } else {
                alert('æ²¡æœ‰æ‰¾åˆ°å¯åŒ¹é…çš„è¡¨æƒ…ï¼');
            }
        }

        // é‡æ’æ¸¸æˆæ¿
        function shuffleBoard() {
            if (!gameState.gameActive) return;
            
            // ä¿å­˜å½“å‰çŠ¶æ€
            const emojiData = gameState.board.map(card => ({
                emoji: card.dataset.emoji,
                count: parseInt(card.dataset.count),
                type: card.dataset.type,
                class: Array.from(card.classList).find(cls => cls.startsWith('item-'))
            }));
            
            // æ¸…ç©ºæ¸¸æˆæ¿
            gameBoardEl.innerHTML = '';
            gameState.board = [];
            
            // é‡æ–°ç”Ÿæˆå¡ç‰‡ï¼ˆä¿æŒç›¸åŒçš„è¡¨æƒ…å’ŒçŠ¶æ€ï¼‰
            emojiData.forEach(data => {
                const card = document.createElement('div');
                card.className = 'card';
                card.textContent = data.emoji;
                card.dataset.emoji = data.emoji;
                card.dataset.count = data.count;
                
                if (data.type) {
                    card.dataset.type = data.type;
                    card.classList.add(data.class);
                }
                
                // æ ¹æ®è®¡æ•°è®¾ç½®èƒŒæ™¯è‰²
                if (data.count === 2) {
                    card.classList.add('darkened');
                } else if (data.count === 3) {
                    card.classList.add('double-darkened');
                }
                
                // æ·»åŠ æ‹–æ‹½äº‹ä»¶
                setupCardEvents(card);
                
                gameBoardEl.appendChild(card);
                gameState.board.push(card);
            });
        }

        // å¯åŠ¨æ¸¸æˆ
        initGame();
    </script>
</body>
</html>